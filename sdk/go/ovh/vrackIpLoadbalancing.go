// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ovh

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Attach a ip loadbalancing to a VRack.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-ovh/sdk/go/ovh"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := ovh.NewVrackIpLoadbalancing(ctx, "viplb", &ovh.VrackIpLoadbalancingArgs{
//				IpLoadbalancing: pulumi.String("yyy"),
//				ServiceName:     pulumi.String("xxx"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type VrackIpLoadbalancing struct {
	pulumi.CustomResourceState

	// The id of the ip loadbalancing.
	IpLoadbalancing pulumi.StringOutput `pulumi:"ipLoadbalancing"`
	// The id of the vrack.
	ServiceName pulumi.StringOutput `pulumi:"serviceName"`
}

// NewVrackIpLoadbalancing registers a new resource with the given unique name, arguments, and options.
func NewVrackIpLoadbalancing(ctx *pulumi.Context,
	name string, args *VrackIpLoadbalancingArgs, opts ...pulumi.ResourceOption) (*VrackIpLoadbalancing, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.IpLoadbalancing == nil {
		return nil, errors.New("invalid value for required argument 'IpLoadbalancing'")
	}
	if args.ServiceName == nil {
		return nil, errors.New("invalid value for required argument 'ServiceName'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource VrackIpLoadbalancing
	err := ctx.RegisterResource("ovh:index/vrackIpLoadbalancing:VrackIpLoadbalancing", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVrackIpLoadbalancing gets an existing VrackIpLoadbalancing resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVrackIpLoadbalancing(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VrackIpLoadbalancingState, opts ...pulumi.ResourceOption) (*VrackIpLoadbalancing, error) {
	var resource VrackIpLoadbalancing
	err := ctx.ReadResource("ovh:index/vrackIpLoadbalancing:VrackIpLoadbalancing", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VrackIpLoadbalancing resources.
type vrackIpLoadbalancingState struct {
	// The id of the ip loadbalancing.
	IpLoadbalancing *string `pulumi:"ipLoadbalancing"`
	// The id of the vrack.
	ServiceName *string `pulumi:"serviceName"`
}

type VrackIpLoadbalancingState struct {
	// The id of the ip loadbalancing.
	IpLoadbalancing pulumi.StringPtrInput
	// The id of the vrack.
	ServiceName pulumi.StringPtrInput
}

func (VrackIpLoadbalancingState) ElementType() reflect.Type {
	return reflect.TypeOf((*vrackIpLoadbalancingState)(nil)).Elem()
}

type vrackIpLoadbalancingArgs struct {
	// The id of the ip loadbalancing.
	IpLoadbalancing string `pulumi:"ipLoadbalancing"`
	// The id of the vrack.
	ServiceName string `pulumi:"serviceName"`
}

// The set of arguments for constructing a VrackIpLoadbalancing resource.
type VrackIpLoadbalancingArgs struct {
	// The id of the ip loadbalancing.
	IpLoadbalancing pulumi.StringInput
	// The id of the vrack.
	ServiceName pulumi.StringInput
}

func (VrackIpLoadbalancingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vrackIpLoadbalancingArgs)(nil)).Elem()
}

type VrackIpLoadbalancingInput interface {
	pulumi.Input

	ToVrackIpLoadbalancingOutput() VrackIpLoadbalancingOutput
	ToVrackIpLoadbalancingOutputWithContext(ctx context.Context) VrackIpLoadbalancingOutput
}

func (*VrackIpLoadbalancing) ElementType() reflect.Type {
	return reflect.TypeOf((**VrackIpLoadbalancing)(nil)).Elem()
}

func (i *VrackIpLoadbalancing) ToVrackIpLoadbalancingOutput() VrackIpLoadbalancingOutput {
	return i.ToVrackIpLoadbalancingOutputWithContext(context.Background())
}

func (i *VrackIpLoadbalancing) ToVrackIpLoadbalancingOutputWithContext(ctx context.Context) VrackIpLoadbalancingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VrackIpLoadbalancingOutput)
}

// VrackIpLoadbalancingArrayInput is an input type that accepts VrackIpLoadbalancingArray and VrackIpLoadbalancingArrayOutput values.
// You can construct a concrete instance of `VrackIpLoadbalancingArrayInput` via:
//
//	VrackIpLoadbalancingArray{ VrackIpLoadbalancingArgs{...} }
type VrackIpLoadbalancingArrayInput interface {
	pulumi.Input

	ToVrackIpLoadbalancingArrayOutput() VrackIpLoadbalancingArrayOutput
	ToVrackIpLoadbalancingArrayOutputWithContext(context.Context) VrackIpLoadbalancingArrayOutput
}

type VrackIpLoadbalancingArray []VrackIpLoadbalancingInput

func (VrackIpLoadbalancingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VrackIpLoadbalancing)(nil)).Elem()
}

func (i VrackIpLoadbalancingArray) ToVrackIpLoadbalancingArrayOutput() VrackIpLoadbalancingArrayOutput {
	return i.ToVrackIpLoadbalancingArrayOutputWithContext(context.Background())
}

func (i VrackIpLoadbalancingArray) ToVrackIpLoadbalancingArrayOutputWithContext(ctx context.Context) VrackIpLoadbalancingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VrackIpLoadbalancingArrayOutput)
}

// VrackIpLoadbalancingMapInput is an input type that accepts VrackIpLoadbalancingMap and VrackIpLoadbalancingMapOutput values.
// You can construct a concrete instance of `VrackIpLoadbalancingMapInput` via:
//
//	VrackIpLoadbalancingMap{ "key": VrackIpLoadbalancingArgs{...} }
type VrackIpLoadbalancingMapInput interface {
	pulumi.Input

	ToVrackIpLoadbalancingMapOutput() VrackIpLoadbalancingMapOutput
	ToVrackIpLoadbalancingMapOutputWithContext(context.Context) VrackIpLoadbalancingMapOutput
}

type VrackIpLoadbalancingMap map[string]VrackIpLoadbalancingInput

func (VrackIpLoadbalancingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VrackIpLoadbalancing)(nil)).Elem()
}

func (i VrackIpLoadbalancingMap) ToVrackIpLoadbalancingMapOutput() VrackIpLoadbalancingMapOutput {
	return i.ToVrackIpLoadbalancingMapOutputWithContext(context.Background())
}

func (i VrackIpLoadbalancingMap) ToVrackIpLoadbalancingMapOutputWithContext(ctx context.Context) VrackIpLoadbalancingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VrackIpLoadbalancingMapOutput)
}

type VrackIpLoadbalancingOutput struct{ *pulumi.OutputState }

func (VrackIpLoadbalancingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VrackIpLoadbalancing)(nil)).Elem()
}

func (o VrackIpLoadbalancingOutput) ToVrackIpLoadbalancingOutput() VrackIpLoadbalancingOutput {
	return o
}

func (o VrackIpLoadbalancingOutput) ToVrackIpLoadbalancingOutputWithContext(ctx context.Context) VrackIpLoadbalancingOutput {
	return o
}

// The id of the ip loadbalancing.
func (o VrackIpLoadbalancingOutput) IpLoadbalancing() pulumi.StringOutput {
	return o.ApplyT(func(v *VrackIpLoadbalancing) pulumi.StringOutput { return v.IpLoadbalancing }).(pulumi.StringOutput)
}

// The id of the vrack.
func (o VrackIpLoadbalancingOutput) ServiceName() pulumi.StringOutput {
	return o.ApplyT(func(v *VrackIpLoadbalancing) pulumi.StringOutput { return v.ServiceName }).(pulumi.StringOutput)
}

type VrackIpLoadbalancingArrayOutput struct{ *pulumi.OutputState }

func (VrackIpLoadbalancingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VrackIpLoadbalancing)(nil)).Elem()
}

func (o VrackIpLoadbalancingArrayOutput) ToVrackIpLoadbalancingArrayOutput() VrackIpLoadbalancingArrayOutput {
	return o
}

func (o VrackIpLoadbalancingArrayOutput) ToVrackIpLoadbalancingArrayOutputWithContext(ctx context.Context) VrackIpLoadbalancingArrayOutput {
	return o
}

func (o VrackIpLoadbalancingArrayOutput) Index(i pulumi.IntInput) VrackIpLoadbalancingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VrackIpLoadbalancing {
		return vs[0].([]*VrackIpLoadbalancing)[vs[1].(int)]
	}).(VrackIpLoadbalancingOutput)
}

type VrackIpLoadbalancingMapOutput struct{ *pulumi.OutputState }

func (VrackIpLoadbalancingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VrackIpLoadbalancing)(nil)).Elem()
}

func (o VrackIpLoadbalancingMapOutput) ToVrackIpLoadbalancingMapOutput() VrackIpLoadbalancingMapOutput {
	return o
}

func (o VrackIpLoadbalancingMapOutput) ToVrackIpLoadbalancingMapOutputWithContext(ctx context.Context) VrackIpLoadbalancingMapOutput {
	return o
}

func (o VrackIpLoadbalancingMapOutput) MapIndex(k pulumi.StringInput) VrackIpLoadbalancingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VrackIpLoadbalancing {
		return vs[0].(map[string]*VrackIpLoadbalancing)[vs[1].(string)]
	}).(VrackIpLoadbalancingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VrackIpLoadbalancingInput)(nil)).Elem(), &VrackIpLoadbalancing{})
	pulumi.RegisterInputType(reflect.TypeOf((*VrackIpLoadbalancingArrayInput)(nil)).Elem(), VrackIpLoadbalancingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VrackIpLoadbalancingMapInput)(nil)).Elem(), VrackIpLoadbalancingMap{})
	pulumi.RegisterOutputType(VrackIpLoadbalancingOutput{})
	pulumi.RegisterOutputType(VrackIpLoadbalancingArrayOutput{})
	pulumi.RegisterOutputType(VrackIpLoadbalancingMapOutput{})
}
