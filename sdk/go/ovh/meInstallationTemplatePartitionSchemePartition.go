// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ovh

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Use this resource to create a partition in the partition scheme of a custom installation template available for dedicated servers.
//
// ## Import
//
// Use the fake id format to import the resource `template_name/scheme_name/mountpoint` (example"mytemplate/myscheme//").
type MeInstallationTemplatePartitionSchemePartition struct {
	pulumi.CustomResourceState

	// Partition filesystem
	Filesystem pulumi.StringOutput `pulumi:"filesystem"`
	// partition mount point
	Mountpoint pulumi.StringOutput `pulumi:"mountpoint"`
	// step or order. specifies the creation order of the partition on the disk
	Order pulumi.IntOutput `pulumi:"order"`
	// raid partition type
	Raid pulumi.StringOutput `pulumi:"raid"`
	// name of this partitioning scheme
	SchemeName pulumi.StringOutput `pulumi:"schemeName"`
	// size of partition in MB, 0 => rest of the space
	Size pulumi.IntOutput `pulumi:"size"`
	// Template name
	TemplateName pulumi.StringOutput `pulumi:"templateName"`
	// partition type
	Type pulumi.StringOutput `pulumi:"type"`
	// The volume name needed for proxmox distribution
	VolumeName pulumi.StringOutput `pulumi:"volumeName"`
}

// NewMeInstallationTemplatePartitionSchemePartition registers a new resource with the given unique name, arguments, and options.
func NewMeInstallationTemplatePartitionSchemePartition(ctx *pulumi.Context,
	name string, args *MeInstallationTemplatePartitionSchemePartitionArgs, opts ...pulumi.ResourceOption) (*MeInstallationTemplatePartitionSchemePartition, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Filesystem == nil {
		return nil, errors.New("invalid value for required argument 'Filesystem'")
	}
	if args.Mountpoint == nil {
		return nil, errors.New("invalid value for required argument 'Mountpoint'")
	}
	if args.Order == nil {
		return nil, errors.New("invalid value for required argument 'Order'")
	}
	if args.SchemeName == nil {
		return nil, errors.New("invalid value for required argument 'SchemeName'")
	}
	if args.Size == nil {
		return nil, errors.New("invalid value for required argument 'Size'")
	}
	if args.TemplateName == nil {
		return nil, errors.New("invalid value for required argument 'TemplateName'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource MeInstallationTemplatePartitionSchemePartition
	err := ctx.RegisterResource("ovh:index/meInstallationTemplatePartitionSchemePartition:MeInstallationTemplatePartitionSchemePartition", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMeInstallationTemplatePartitionSchemePartition gets an existing MeInstallationTemplatePartitionSchemePartition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMeInstallationTemplatePartitionSchemePartition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MeInstallationTemplatePartitionSchemePartitionState, opts ...pulumi.ResourceOption) (*MeInstallationTemplatePartitionSchemePartition, error) {
	var resource MeInstallationTemplatePartitionSchemePartition
	err := ctx.ReadResource("ovh:index/meInstallationTemplatePartitionSchemePartition:MeInstallationTemplatePartitionSchemePartition", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MeInstallationTemplatePartitionSchemePartition resources.
type meInstallationTemplatePartitionSchemePartitionState struct {
	// Partition filesystem
	Filesystem *string `pulumi:"filesystem"`
	// partition mount point
	Mountpoint *string `pulumi:"mountpoint"`
	// step or order. specifies the creation order of the partition on the disk
	Order *int `pulumi:"order"`
	// raid partition type
	Raid *string `pulumi:"raid"`
	// name of this partitioning scheme
	SchemeName *string `pulumi:"schemeName"`
	// size of partition in MB, 0 => rest of the space
	Size *int `pulumi:"size"`
	// Template name
	TemplateName *string `pulumi:"templateName"`
	// partition type
	Type *string `pulumi:"type"`
	// The volume name needed for proxmox distribution
	VolumeName *string `pulumi:"volumeName"`
}

type MeInstallationTemplatePartitionSchemePartitionState struct {
	// Partition filesystem
	Filesystem pulumi.StringPtrInput
	// partition mount point
	Mountpoint pulumi.StringPtrInput
	// step or order. specifies the creation order of the partition on the disk
	Order pulumi.IntPtrInput
	// raid partition type
	Raid pulumi.StringPtrInput
	// name of this partitioning scheme
	SchemeName pulumi.StringPtrInput
	// size of partition in MB, 0 => rest of the space
	Size pulumi.IntPtrInput
	// Template name
	TemplateName pulumi.StringPtrInput
	// partition type
	Type pulumi.StringPtrInput
	// The volume name needed for proxmox distribution
	VolumeName pulumi.StringPtrInput
}

func (MeInstallationTemplatePartitionSchemePartitionState) ElementType() reflect.Type {
	return reflect.TypeOf((*meInstallationTemplatePartitionSchemePartitionState)(nil)).Elem()
}

type meInstallationTemplatePartitionSchemePartitionArgs struct {
	// Partition filesystem
	Filesystem string `pulumi:"filesystem"`
	// partition mount point
	Mountpoint string `pulumi:"mountpoint"`
	// step or order. specifies the creation order of the partition on the disk
	Order int `pulumi:"order"`
	// raid partition type
	Raid *string `pulumi:"raid"`
	// name of this partitioning scheme
	SchemeName string `pulumi:"schemeName"`
	// size of partition in MB, 0 => rest of the space
	Size int `pulumi:"size"`
	// Template name
	TemplateName string `pulumi:"templateName"`
	// partition type
	Type string `pulumi:"type"`
	// The volume name needed for proxmox distribution
	VolumeName *string `pulumi:"volumeName"`
}

// The set of arguments for constructing a MeInstallationTemplatePartitionSchemePartition resource.
type MeInstallationTemplatePartitionSchemePartitionArgs struct {
	// Partition filesystem
	Filesystem pulumi.StringInput
	// partition mount point
	Mountpoint pulumi.StringInput
	// step or order. specifies the creation order of the partition on the disk
	Order pulumi.IntInput
	// raid partition type
	Raid pulumi.StringPtrInput
	// name of this partitioning scheme
	SchemeName pulumi.StringInput
	// size of partition in MB, 0 => rest of the space
	Size pulumi.IntInput
	// Template name
	TemplateName pulumi.StringInput
	// partition type
	Type pulumi.StringInput
	// The volume name needed for proxmox distribution
	VolumeName pulumi.StringPtrInput
}

func (MeInstallationTemplatePartitionSchemePartitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*meInstallationTemplatePartitionSchemePartitionArgs)(nil)).Elem()
}

type MeInstallationTemplatePartitionSchemePartitionInput interface {
	pulumi.Input

	ToMeInstallationTemplatePartitionSchemePartitionOutput() MeInstallationTemplatePartitionSchemePartitionOutput
	ToMeInstallationTemplatePartitionSchemePartitionOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionOutput
}

func (*MeInstallationTemplatePartitionSchemePartition) ElementType() reflect.Type {
	return reflect.TypeOf((**MeInstallationTemplatePartitionSchemePartition)(nil)).Elem()
}

func (i *MeInstallationTemplatePartitionSchemePartition) ToMeInstallationTemplatePartitionSchemePartitionOutput() MeInstallationTemplatePartitionSchemePartitionOutput {
	return i.ToMeInstallationTemplatePartitionSchemePartitionOutputWithContext(context.Background())
}

func (i *MeInstallationTemplatePartitionSchemePartition) ToMeInstallationTemplatePartitionSchemePartitionOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeInstallationTemplatePartitionSchemePartitionOutput)
}

// MeInstallationTemplatePartitionSchemePartitionArrayInput is an input type that accepts MeInstallationTemplatePartitionSchemePartitionArray and MeInstallationTemplatePartitionSchemePartitionArrayOutput values.
// You can construct a concrete instance of `MeInstallationTemplatePartitionSchemePartitionArrayInput` via:
//
//	MeInstallationTemplatePartitionSchemePartitionArray{ MeInstallationTemplatePartitionSchemePartitionArgs{...} }
type MeInstallationTemplatePartitionSchemePartitionArrayInput interface {
	pulumi.Input

	ToMeInstallationTemplatePartitionSchemePartitionArrayOutput() MeInstallationTemplatePartitionSchemePartitionArrayOutput
	ToMeInstallationTemplatePartitionSchemePartitionArrayOutputWithContext(context.Context) MeInstallationTemplatePartitionSchemePartitionArrayOutput
}

type MeInstallationTemplatePartitionSchemePartitionArray []MeInstallationTemplatePartitionSchemePartitionInput

func (MeInstallationTemplatePartitionSchemePartitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MeInstallationTemplatePartitionSchemePartition)(nil)).Elem()
}

func (i MeInstallationTemplatePartitionSchemePartitionArray) ToMeInstallationTemplatePartitionSchemePartitionArrayOutput() MeInstallationTemplatePartitionSchemePartitionArrayOutput {
	return i.ToMeInstallationTemplatePartitionSchemePartitionArrayOutputWithContext(context.Background())
}

func (i MeInstallationTemplatePartitionSchemePartitionArray) ToMeInstallationTemplatePartitionSchemePartitionArrayOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeInstallationTemplatePartitionSchemePartitionArrayOutput)
}

// MeInstallationTemplatePartitionSchemePartitionMapInput is an input type that accepts MeInstallationTemplatePartitionSchemePartitionMap and MeInstallationTemplatePartitionSchemePartitionMapOutput values.
// You can construct a concrete instance of `MeInstallationTemplatePartitionSchemePartitionMapInput` via:
//
//	MeInstallationTemplatePartitionSchemePartitionMap{ "key": MeInstallationTemplatePartitionSchemePartitionArgs{...} }
type MeInstallationTemplatePartitionSchemePartitionMapInput interface {
	pulumi.Input

	ToMeInstallationTemplatePartitionSchemePartitionMapOutput() MeInstallationTemplatePartitionSchemePartitionMapOutput
	ToMeInstallationTemplatePartitionSchemePartitionMapOutputWithContext(context.Context) MeInstallationTemplatePartitionSchemePartitionMapOutput
}

type MeInstallationTemplatePartitionSchemePartitionMap map[string]MeInstallationTemplatePartitionSchemePartitionInput

func (MeInstallationTemplatePartitionSchemePartitionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MeInstallationTemplatePartitionSchemePartition)(nil)).Elem()
}

func (i MeInstallationTemplatePartitionSchemePartitionMap) ToMeInstallationTemplatePartitionSchemePartitionMapOutput() MeInstallationTemplatePartitionSchemePartitionMapOutput {
	return i.ToMeInstallationTemplatePartitionSchemePartitionMapOutputWithContext(context.Background())
}

func (i MeInstallationTemplatePartitionSchemePartitionMap) ToMeInstallationTemplatePartitionSchemePartitionMapOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MeInstallationTemplatePartitionSchemePartitionMapOutput)
}

type MeInstallationTemplatePartitionSchemePartitionOutput struct{ *pulumi.OutputState }

func (MeInstallationTemplatePartitionSchemePartitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MeInstallationTemplatePartitionSchemePartition)(nil)).Elem()
}

func (o MeInstallationTemplatePartitionSchemePartitionOutput) ToMeInstallationTemplatePartitionSchemePartitionOutput() MeInstallationTemplatePartitionSchemePartitionOutput {
	return o
}

func (o MeInstallationTemplatePartitionSchemePartitionOutput) ToMeInstallationTemplatePartitionSchemePartitionOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionOutput {
	return o
}

// Partition filesystem
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Filesystem() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.Filesystem }).(pulumi.StringOutput)
}

// partition mount point
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Mountpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.Mountpoint }).(pulumi.StringOutput)
}

// step or order. specifies the creation order of the partition on the disk
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Order() pulumi.IntOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.IntOutput { return v.Order }).(pulumi.IntOutput)
}

// raid partition type
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Raid() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.Raid }).(pulumi.StringOutput)
}

// name of this partitioning scheme
func (o MeInstallationTemplatePartitionSchemePartitionOutput) SchemeName() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.SchemeName }).(pulumi.StringOutput)
}

// size of partition in MB, 0 => rest of the space
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.IntOutput { return v.Size }).(pulumi.IntOutput)
}

// Template name
func (o MeInstallationTemplatePartitionSchemePartitionOutput) TemplateName() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.TemplateName }).(pulumi.StringOutput)
}

// partition type
func (o MeInstallationTemplatePartitionSchemePartitionOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The volume name needed for proxmox distribution
func (o MeInstallationTemplatePartitionSchemePartitionOutput) VolumeName() pulumi.StringOutput {
	return o.ApplyT(func(v *MeInstallationTemplatePartitionSchemePartition) pulumi.StringOutput { return v.VolumeName }).(pulumi.StringOutput)
}

type MeInstallationTemplatePartitionSchemePartitionArrayOutput struct{ *pulumi.OutputState }

func (MeInstallationTemplatePartitionSchemePartitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*MeInstallationTemplatePartitionSchemePartition)(nil)).Elem()
}

func (o MeInstallationTemplatePartitionSchemePartitionArrayOutput) ToMeInstallationTemplatePartitionSchemePartitionArrayOutput() MeInstallationTemplatePartitionSchemePartitionArrayOutput {
	return o
}

func (o MeInstallationTemplatePartitionSchemePartitionArrayOutput) ToMeInstallationTemplatePartitionSchemePartitionArrayOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionArrayOutput {
	return o
}

func (o MeInstallationTemplatePartitionSchemePartitionArrayOutput) Index(i pulumi.IntInput) MeInstallationTemplatePartitionSchemePartitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *MeInstallationTemplatePartitionSchemePartition {
		return vs[0].([]*MeInstallationTemplatePartitionSchemePartition)[vs[1].(int)]
	}).(MeInstallationTemplatePartitionSchemePartitionOutput)
}

type MeInstallationTemplatePartitionSchemePartitionMapOutput struct{ *pulumi.OutputState }

func (MeInstallationTemplatePartitionSchemePartitionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*MeInstallationTemplatePartitionSchemePartition)(nil)).Elem()
}

func (o MeInstallationTemplatePartitionSchemePartitionMapOutput) ToMeInstallationTemplatePartitionSchemePartitionMapOutput() MeInstallationTemplatePartitionSchemePartitionMapOutput {
	return o
}

func (o MeInstallationTemplatePartitionSchemePartitionMapOutput) ToMeInstallationTemplatePartitionSchemePartitionMapOutputWithContext(ctx context.Context) MeInstallationTemplatePartitionSchemePartitionMapOutput {
	return o
}

func (o MeInstallationTemplatePartitionSchemePartitionMapOutput) MapIndex(k pulumi.StringInput) MeInstallationTemplatePartitionSchemePartitionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *MeInstallationTemplatePartitionSchemePartition {
		return vs[0].(map[string]*MeInstallationTemplatePartitionSchemePartition)[vs[1].(string)]
	}).(MeInstallationTemplatePartitionSchemePartitionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MeInstallationTemplatePartitionSchemePartitionInput)(nil)).Elem(), &MeInstallationTemplatePartitionSchemePartition{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeInstallationTemplatePartitionSchemePartitionArrayInput)(nil)).Elem(), MeInstallationTemplatePartitionSchemePartitionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MeInstallationTemplatePartitionSchemePartitionMapInput)(nil)).Elem(), MeInstallationTemplatePartitionSchemePartitionMap{})
	pulumi.RegisterOutputType(MeInstallationTemplatePartitionSchemePartitionOutput{})
	pulumi.RegisterOutputType(MeInstallationTemplatePartitionSchemePartitionArrayOutput{})
	pulumi.RegisterOutputType(MeInstallationTemplatePartitionSchemePartitionMapOutput{})
}
